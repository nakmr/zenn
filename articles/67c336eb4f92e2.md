---
title: "関数型アプローチをPythonで実践してみよう"
emoji: "😊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Python, 関数型プログラミング, OpenAI]
published: false
publication_name: "acntechjp"
published_at: 2024-09-24 08:45
---

<!-- textlint-disable -->
:::details change log
2024/09/24 投稿
:::
<!-- textlint-enable -->

# はじめに

本記事では、関数型プログラミングの基本概念をPythonを用いて解説し、実際にプログラムを作成しながら実践します。
関数型プログラミングとは、コードの安全性や再利用性を高めるために、値を変更しない「イミュータブルなデータ」と「純粋関数」を中心としたアプローチです。

本記事の土台は、筆者が関数型プログラミングについて学習/整理した内容なので、高度に専門的ではないことや、実践の過程であることに留意ください。


## 誰に向けた記事か

本記事は、こんな人に向けて書かれています。

本記事は、以下のような方々に向けて書かれています。

- 関数型プログラミングの基本を知りたい、または触れてみたい方
- Pythonで関数型プログラミングを試してみたいが、どこから始めればよいか迷っている方
- 生成AIとチャットする機能を実装しながら、関数型プログラミングの特徴を学びたい方
- ここまで読んで、なんか気になってしまった人


## 誰に向けた記事ではないか

本記事は、こんな人が読むと「自分向けじゃなかった...」となります。

- 数学的に厳密な関数型プログラミング理論を学びたい方
- すでに関数型プログラミングを習得しており、より高度な技術に挑戦したい方


## 本記事を読んだ後にどうなるか

本記事を読み終わると、あなたはこのような状態になっています。

- 関数のシグネチャに、その関数に関すること全てが表れている「嘘をつかない関数」の重要さを説明できる
- 読む前よりも、関数型プログラミングへの興味が強くなっている
- 何なら、好きになっている

## 何を実装するのか

本記事では、Pythonを使ってOpenAI APIを活用したチャットボット機能を実装します。この機能はコンソールベースで動作し、ユーザーが終了するまでチャットが継続します。
オブジェクト指向での実装と関数型プログラミングでの実装の違いを比較しながら、関数型プログラミングの特徴を学んでいきます。

# オブジェクト指向な書き方

まずはオブジェクト指向な書き方で、チャット機能を実装します。

オブジェクト指向の基本的な考え方は、役割ごとにクラスを作成し、そのクラスが（役割を担うために）必要とする処理（メソッド）をクラス内に実装します。
本記事では`ChatBot`クラスを作成し、このクラス内にチャット機能を実装していきます。


```python:oop.py
import httpx
from typing import Dict, Any, Optional, List


class ChatBot:
    def __init__(self, api_key: str):
        """
        ChatBotクラスのコンストラクタ。APIキーを設定し、メッセージ履歴を初期化します。

        Args:
            api_key (str): OpenAI APIキー。
        """
        self.api_key = api_key
        self.messages = []  # メッセージ履歴を保持するリスト

    def _create_and_send_message(self, user_message: str) -> str:
        """
        ユーザーからのメッセージを基にOpenAIとやり取りし、アシスタントからのレスポンスを取得します。

        Args:
            user_message (str): ユーザーからのメッセージ。

        Returns:
            Optional[str]: アシスタントからのメッセージ。失敗した場合はNone。
        """
        # メッセージ履歴にユーザーのメッセージを追加
        self.messages.append({"role": "user", "content": user_message})

        # OpenAI APIに送信するペイロードを作成
        payload = {
            "model": "gpt-4o",
            "messages": self.messages,
            "temperature": 0.7,
        }

        # OpenAI APIへのリクエスト
        url = "https://api.openai.com/v1/chat/completions"
        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}

        try:
            response = httpx.post(url=url, headers=headers, json=payload, timeout=None)
            data = response.raise_for_status().json()
        except httpx.HTTPStatusError as exc:
            print(
                f"エラーが発生しました。ステータスコード: {exc.response.status_code}, メッセージ: {exc.response.text}"
            )

        # アシスタントのレスポンスを取得してメッセージ履歴に追加
        assistant_message = data["choices"][0]["message"]["content"]
        self.messages.append({"role": "assistant", "content": assistant_message})

        return assistant_message

    def start_chat(self) -> None:
        """
        LLMとのチャットを開始します。
        """
        while True:
            user_message = input("メッセージを入力してください (`/end` で終了): ")
            if user_message == "/end":
                break

            assistant_message = self._create_and_send_message(user_message)
            if assistant_message:
                print(f"LLM: {assistant_message}")


if __name__ == "__main__":
    import os
    from dotenv import load_dotenv

    load_dotenv()
    chatbot = ChatBot(api_key=os.getenv("OPENAI_API_KEY"))
    chatbot.start_chat()
```

:::message
OpenAI APIの利用にはPython用クライアントモジュール`openai`を利用するのが常套手段ですが、HTTP通信に関わる例外処理について言及するため、あえて利用しません。
<!-- textlint-disable -->
:::
<!-- textlint-enable -->

<!-- textlint-disable -->
:::details 実行結果の例
<!-- textlint-enable -->
```bash
メッセージを入力してください (`/end` で終了): 今東京にいるんだけど、めちゃ暑いっす
LLM: 東京の夏は確かに暑いですね！湿度も高いので、体感温度がさらに上がります。水分をこまめに摂ること、日陰や冷房の効いた場所で休むことが大切です。もし外出するなら、帽子や日傘を使って日差しを避けると少し楽になりますよ。また、冷たい飲み物やアイスクリームを楽しむのもいいですね。本当に暑い日は、無理せず涼しい場所で過ごすことをお勧めします。体調には気をつけてくださいね！
メッセージを入力してください (`/end` で終了): 今僕はどこにいるんだっけ？
LLM: あなたは「今東京にいる」とおっしゃっていましたね。東京のどのエリアにいるかまではわかりませんが、東京の暑さには気をつけて過ごしてください。もし具体的な場所やおすすめのスポットについて知りたいことがあれば、教えてください！
メッセージを入力してください (`/end` で終了): /end
```
<!-- textlint-disable -->
:::
<!-- textlint-enable -->


# 関数型プログラミングの観点でツッコミを入れてみよう

いったん、オブジェクト指向を念頭にチャット機能を実装したところ、Pythonコードに、関数型プログラミングの観点からツッコミを入れてみましょう。
ツッコミを入れるためには、本記事における「関数型プログラミングとはなんぞや」が必要になるので、ここで定義します。


## 本記事における関数型プログラミングとは？

本記事で関数型プログラミングを実践するにあたって、「[なっとく！関数型プログラミング](https://www.shoeisha.co.jp/book/detail/9784798179803)」から、下記の用語と定義を拝借します。

**関数型プログラミング**

> 関数型プログラミングとは イミュータブルな値を操作する純粋関数を利用するプログラミングである (P.70)

**純粋関数**

> - 戻り値は1つだけ
> - 引数のみに基づいて戻り値を計算する
> - 既存の値を変更しない
> 
> (P.46)

<!-- textlint-disable -->
また同書では、純粋関数の定義「引数にのみ基づいて戻り値を計算する」を
<!-- textlint-enable -->

> 関数のシグネチャは嘘をついてはいけない

と言い直しています。どういうことでしょうか？
関数のシグネチャとは関数名、引数、戻り値を表す部分を指します。

```python
def add_two_numbers(num1: int, num2: int) -> int: # <- シグネチャ
    return num1 + num2 # <- 本体（関数の実体）
```

「関数のシグネチャは嘘をつく」とは、関数がシグネチャに書いてある引数以外を利用して計算したり、戻り値以外を返す（例えば、例外のスロー）ことを指しています。
言い換えると、その関数が何をするのかはシグネチャに全て書いてあるべきであり、シグネチャから読み取れない処理を関数は行ってはいけない、ということを意味しています。

例えば上記関数`add_two_numbers`のシグネチャからは、「引数にある2つの整数（`int`型）を足した結果（`int`型であり、1つ）を返す」ことが容易に読み取れます。したがって、この関数のシグネチャは嘘つきでないと言えます。

本記事で関数型プログラミングを実践するにあたっては、この指摘を関数型プログラミングの観点に加えます。

**関心の分離**

あともう1つ、関数型プログラミングを実践する上で重要な考え方である「関心の分離」も本記事における関数型プログラミングの要件に加えます。
<!-- textlint-disable -->
関心の分離とは
<!-- textlint-enable -->

> それぞれのコードがそれぞれの責任を負い、そのことにのみ関心を持つ (P.29)

ようにコードを作成することを言います。
つまり、1つの関数が複数の責務や関心領域を持たないように責務や関心領域の単位で関数を作成し、それらを組み合わせて機能全体を成り立たせることを目指します。

## ツッコミの観点

以上を整理すると、本記事における関数型プログラミングのツッコミ観点は下記2つとなります。

**1. 関数のシグネチャが嘘をついていないか？**
**2. イミュータブルな値のみを操作しているか？**
**3. 関心が分離されているか？**

この2つのツッコミにYESと答えられれば、本記事では、そのコードは関数型プログラミンを実践している、と言えることにします。

## ツッコミを入れる

`ChatBot`クラスの各メソッドに対して関数型プログラミングの観点からツッコミを入れていきましょう。

<!-- textlint-disable -->
:::message
<!-- textlint-enable -->
`def __init__(self, api_key: str):`はPythonの特殊メソッドのため、ツッコミ対象から外します。
<!-- textlint-disable -->
:::
<!-- textlint-enable -->

### `def _create_and_send_message(self, user_message: str) -> str:`

#### 1. 関数のシグネチャが嘘をついていないか？ ---> No

シグネチャから読み取れることは下記のとおりです。

- 関数名の先頭に`_`があることから、クラス内でのみ使うことを開発者が意図していた[^1]
- 関数名から、この関数はメッセージを作成して送信する
- 引数と戻り値から、この関数は（インスタンスと）`str`型の「ユーザメッセージ」を受け取って、`str`型のナニカを返す

[^1]: [PEP 8 – Style Guide for Python Code / Descriptive: Naming Styles](https://peps.python.org/pep-0008/#descriptive-naming-styles)

関数の本体を見ると、このシグネチャに書かれていない重要な処理があります。それは例外処理です。
例外処理のハンドリングに関して、シグネチャに書かれていないことは下記の3つです。

1. OpenAI APIへのHTTP通信時に例外`httpx.HTTPStatusError`が発生し得る
2. 例外発生時はコンソールにメッセージを出力する
3. 例外発生時は`str`型のナニカを返さない

この関数のシグネチャは3つの嘘をついているので、このツッコミへの回答はNoとなります。

#### 2. イミュータブルな値のみを操作しているか？ ---> No

このメソッドではミュータブルな値`self.messages`に会話履歴を何度もappendしているため、このツッコミへの回答はNoとなります。

#### 3. 関心が分離されているか？ ---> No

この関数が持っている処理は下記の3つです。

- 会話履歴の更新
- OpenAI APIへ送信するペイロードの組み立て
- HTTP通信とそれに伴う例外処理

つまりこの関数の関心事が3つもあることになり、関心が分離されているとは言えません。そのため、このツッコミへの回答はNoとなります。


### `def start_chat(self) -> None:`

#### 1. 関数のシグネチャが嘘をついていないか？ ---> No

シグネチャからは、チャットを開始することと、`None`を返すことがわかります。
関数本体を見ると、`user_message == "/end`が`True`のとき、`break`が呼び出され、処理が強制的に終了しています。この内容はシグネチャに表れていません。そのため、このツッコミへの回答はNoとなります。

#### 2. イミュータブルな値のみを操作しているか？ ---> Yes

この関数ではミュータブル/イミュータブルな値の操作が発生していないため、Yesとなります。


#### 3. 関心が分離されているか？ ---> Yes

この関数は、ユーザとLLMとのチャットを継続させることだけに責務を負っているため、Noとなります。



# 関数型プログラミングで書き直す

## 書き直しの方針

これまでに整理したことから、書き直しの方針は下記のとおりです。

**1. メッセージ履歴のイミュータブル化**

`self.messages`は、メッセージ履歴を保持するためのミュータブルなリストとして実装されています。これをイミュータブルなデータ構造に置き換え、関数が新しい状態を生成するたびに履歴を更新するように書き換えます

**2. 例外処理の明示**

`httpx.post`の通信エラー処理は、関数のシグネチャに反映されていません。関数のシグネチャに例外処理を明示的に含めることで、嘘をつかない関数を実現します。そのために、関数の戻り値がエラー状態を正しく表すように、`Optional`などの型を活用します。

**3. 関数を処理単位に分割**

`_create_and_send_message`には複数の関心事が同居しています。この関数を処理単位に分割することで、関心の分離が達成された関数を組み合わせてチャット機能が実現されるように書き換えます。


## いざ実践

### 1. メッセージ履歴のイミュータブル化

メッセージ履歴の保持において、一度宣言したコレクションを使い回すのではなく、メッセージを追加するたびに、新しいコレクションを生成するように書き換えます。

```python
# メッセージ履歴を保持するためのユーザ定義型
Message = Tuple[str, str]  # (role, content)

def create_message(role: str, content: str) -> Message:
    """
    新しいメッセージを作成する純粋関数。

    Args:
        role (str): メッセージの役割（例: 'user', 'assistant'）
        content (str): メッセージの内容

    Returns:
        Message: 新しいメッセージ
    """
    return (role, content)

def update_massage(prev_messages: List[Message], new_message: Message) -> List[Message]:
    """
    新しいメッセージを追加したリストを作成する純粋関数。

    Args:
        prev_messages (List[Message]): 会話履歴
        new_message (Message): 追加するメッセージ

    Returns:
        List[Message]: 新しい会話履歴
    """
    return prev_messages + [new_message]
```



### 2. 例外処理の明示

Open AI APIへとHTTP通信を行う関数のシグネチャに例外が発生することを示すにはどうするか？


他の言語の話になりますが、例えばJavaの場合、ある関数が検査例外を投げる可能性があることを、関数の利用者に伝える＝シグネチャに含める方法の定番として、関数シグネチャで検査例外をスローする可能性があることを宣言する、という方法があります。

```java
// 検査例外を投げるカスタム関数
public static void performOperation(int value) throws CustomCheckedException {
    if (value < 0) {
        throw new CustomCheckedException("負の値は許可されていません: " + value);
    }
    System.out.println("処理成功: " + value);
}
```

この場合、関数のシグネチャに`throws CustomCheckedException`とあり、この関数の利用者は、この関数が`CustomCheckedException`をスローする可能性があることを、シグネチャから読み取れます。

:::message
ここで「Javaであれば、検査例外を使えばよい」と言いたいわけではありません。検査例外を使ってしまうと、この関数の利用者は`try-catch`を実装する必要が生まれることから、関数が使いにくくなってしまうことが挙げられます。あくまで、Pythonとの比較を目的とした記述となります。
:::

しかしながら、PythonにはJavaでいうところの検査例外というものがなく、上記のような書き方はできません。そのため、関数内で例外をスローする場合、その関数の利用者はシグネチャからは、例外をスローする可能性があることを読み取れません。

そこで、Python`typing`モジュールの`Optional`型を利用します。
`Optional`は指定した型と`None`との直和を表現する型です。例えば`Optional[str]`とすると、この型は「`str`または`None`である」ことを表現しています。

これを使うと、例外が発生する可能性がある処理において

- 正常終了であれば、指定した型を返す
- 例外発生であれば、`None`を返す

という戻り値の「出し分け」が可能となり、それを関数のシグネチャで表現することができるのです。

つまり、例えば、戻り値が`Optional[str]`である関数の利用者は、「この関数は正常終了時には`str`を、異常終了時には`None`が返ってくる」とわかり、それゆえに、この関数の戻り値に対して、`None`か否かで処理を分岐させることができるのです。
くわえてこの際、関数を`try-except`で囲んで、どんな例外がスローされるのかを事前に確認する必要はなく、ただ戻り値が`None`か否かを確認すればよいため、利用者にとっても使いやすい関数となります。

ということで、OpenAI APIとHTTP通信を行う関数を作成しましょう。

```python
def send_message(api_key: str, messages: List[Message]) -> Optional[str]:
    """
    OpenAI APIにメッセージを送信する純粋関数。

    Args:
        api_key (str): OpenAI APIキー。
        messages (List[Message]): メッセージ履歴のリスト。

    Returns:
        Optional[str]: LLMの返答。通信に失敗した場合はNone。
    """
    url = "https://api.openai.com/v1/chat/completions"
    headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
    payload = {
        "model": "gpt-4o",
        "messages": [{"role": role, "content": content} for role, content in messages],
        "temperature": 0.7,
    }

    try:
        response = httpx.post(url, headers=headers, json=payload)
        data = response.raise_for_status().json()
        return data["choices"][0]["message"]["content"]
    except httpx.HTTPStatusError:
        return None
```



### 3. 関数を処理単位に分割





# 本記事の次ステップ

関数型プログラミングに限らず、関数のシグネチャに「その関数はどんな型（ドメイン）を引数として受け取るのか？」「どんな型を返すのか？」が示されていることが重要です。
これまで実装では、Pythonの組み込み型と標準ライブラリ `typing` を使ってきましたが、ユーザ定義型を使うことで、関数シグネチャが示す情報を充実させることが必要です。
そのため、次のステップとしては、Pythonの型システムを活用することで、関数のシグネチャを充実させることを目指します。