---
title: "関数型プログラミングをPythonで実践してみよう"
emoji: "😊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Python, 関数型プログラミング, OpenAI]
published: false
publication_name: "acntechjp"
---

<!-- textlint-disable -->
:::details change log
2024/09/17 投稿
:::
<!-- textlint-enable -->

# はじめに

本記事では、関数型プログラミングの基本概念をPythonを用いて解説し、実際にプログラムを作成しながら実践します。
関数型プログラミングとは、コードの安全性や再利用性を高めるために、値を変更しない「イミュータブルなデータ」と「純粋関数」を中心としたアプローチです。

本記事の土台は、筆者が関数型プログラミングについて学習/整理した内容なので、高度に専門的ではないことや、実践の過程であることに留意ください。


## 誰に向けた記事か

本記事は、こんな人に向けて書かれています。

本記事は、以下のような方々に向けて書かれています。

- 関数型プログラミングの基本を知りたい、または触れてみたい方
- Pythonで関数型プログラミングを試してみたいが、どこから始めればよいか迷っている方
- 生成AIとチャットする機能を実装しながら、関数型プログラミングの特徴を学びたい方
- ここまで読んで、なんか気になってしまった人


## 誰に向けた記事ではないか

本記事は、こんな人が読むと「自分向けじゃなかった...」となります。

- 数学的に厳密な関数型プログラミング理論を学びたい方
- すでに関数型プログラミングを習得しており、より高度な技術に挑戦したい方


## 本記事を読んだ後にどうなるか

本記事を読み終わると、あなたはこのような状態になっています。

- 関数のシグネチャに、その関数に関すること全てが表れている「嘘をつかない関数」の重要さを説明できる
- 読む前よりも、関数型プログラミングへの興味が強くなっている
- 何なら、好きになっている

## 何を実装するのか

本記事では、Pythonを使ってOpenAI APIを活用したチャットボット機能を実装します。この機能はコンソールベースで動作し、ユーザーが終了するまでチャットが継続します。
オブジェクト指向での実装と関数型プログラミングでの実装の違いを比較しながら、関数型プログラミングの特徴を学んでいきます。

# オブジェクト指向な書き方

まずはオブジェクト指向な書き方で、チャット機能を実装します。

オブジェクト指向の基本的な考え方は、役割ごとにクラスを作成し、そのクラスが（役割を担うために）必要とする処理（メソッド）をクラス内に実装します。
本記事では`ChatBot`クラスを作成し、このクラス内にチャット機能を実装していきます。


```python:oop.py
import httpx
from typing import Dict, Any, Optional, List


class ChatBot:
    def __init__(self, api_key: str):
        """
        ChatBotクラスのコンストラクタ。APIキーを設定し、メッセージ履歴を初期化します。

        Args:
            api_key (str): OpenAI APIキー。
        """
        self.api_key = api_key
        self.messages = []  # メッセージ履歴を保持するリスト

    def _create_and_send_message(self, user_message: str) -> str:
        """
        ユーザーからのメッセージを基にOpenAIとやり取りし、アシスタントからのレスポンスを取得します。

        Args:
            user_message (str): ユーザーからのメッセージ。

        Returns:
            Optional[str]: アシスタントからのメッセージ。失敗した場合はNone。
        """
        # メッセージ履歴にユーザーのメッセージを追加
        self.messages.append({"role": "user", "content": user_message})

        # OpenAI APIに送信するペイロードを作成
        payload = {
            "model": "gpt-4o",
            "messages": self.messages,
            "temperature": 0.7,
        }

        # OpenAI APIへのリクエスト
        url = "https://api.openai.com/v1/chat/completions"
        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}

        try:
            response = httpx.post(url=url, headers=headers, json=payload, timeout=None)
            data = response.raise_for_status().json()
        except httpx.HTTPStatusError as exc:
            print(
                f"エラーが発生しました。ステータスコード: {exc.response.status_code}, メッセージ: {exc.response.text}"
            )

        # アシスタントのレスポンスを取得してメッセージ履歴に追加
        assistant_message = data["choices"][0]["message"]["content"]
        self.messages.append({"role": "assistant", "content": assistant_message})

        return assistant_message

    def start_chat(self) -> None:
        """
        LLMとのチャットを開始します。
        """
        while True:
            user_message = input("メッセージを入力してください (`/end` で終了): ")
            if user_message == "/end":
                break

            assistant_message = self._create_and_send_message(user_message)
            if assistant_message:
                print(f"LLM: {assistant_message}")


if __name__ == "__main__":
    import os
    from dotenv import load_dotenv

    load_dotenv()
    chatbot = ChatBot(api_key=os.getenv("OPENAI_API_KEY"))
    chatbot.start_chat()
```

:::message
OpenAI APIの利用にはPython用クライアントモジュール`openai`を利用するのが常套手段ですが、HTTP通信に関わる例外処理について言及するため、あえて利用しません。
<!-- textlint-disable -->
:::
<!-- textlint-enable -->

<!-- textlint-disable -->
:::details 実行結果の例
<!-- textlint-enable -->
```bash
メッセージを入力してください (`/end` で終了): 今東京にいるんだけど、めちゃ暑いっす
LLM: 東京の夏は確かに暑いですね！湿度も高いので、体感温度がさらに上がります。水分をこまめに摂ること、日陰や冷房の効いた場所で休むことが大切です。もし外出するなら、帽子や日傘を使って日差しを避けると少し楽になりますよ。また、冷たい飲み物やアイスクリームを楽しむのもいいですね。本当に暑い日は、無理せず涼しい場所で過ごすことをお勧めします。体調には気をつけてくださいね！
メッセージを入力してください (`/end` で終了): 今僕はどこにいるんだっけ？
LLM: あなたは「今東京にいる」とおっしゃっていましたね。東京のどのエリアにいるかまではわかりませんが、東京の暑さには気をつけて過ごしてください。もし具体的な場所やおすすめのスポットについて知りたいことがあれば、教えてください！
メッセージを入力してください (`/end` で終了): /end
```
<!-- textlint-disable -->
:::
<!-- textlint-enable -->


# 関数型プログラミングの観点でツッコミを入れてみよう

いったん、オブジェクト指向を念頭にチャット機能を実装したところ、Pythonコードに、関数型プログラミングの観点からツッコミを入れてみましょう。
ツッコミを入れるためには、本記事における「関数型プログラミングとはなんぞや」が必要になるので、ここで定義します。


## 本記事における関数型プログラミングとは？

本記事で関数型プログラミングを実践するにあたって、「[なっとく！関数型プログラミング](https://www.shoeisha.co.jp/book/detail/9784798179803)」から、下記の用語と定義を拝借します。

**関数型プログラミング**

> 関数型プログラミングとは イミュータブルな値を操作する純粋関数を利用するプログラミングである (P.70)

**純粋関数**

> - 戻り値は1つだけ
> - 引数のみに基づいて戻り値を計算する
> - 既存の値を変更しない
> 
> (P.46)

<!-- textlint-disable -->
また同書では、純粋関数の定義「引数にのみ基づいて戻り値を計算する」を
<!-- textlint-enable -->

> 関数のシグネチャは嘘をついてはいけない

と言い直しています。どういうことでしょうか？
関数のシグネチャとは関数名、引数、戻り値を表す部分を指します。

```python
def add_two_numbers(num1: int, num2: int) -> int: # <- シグネチャ
    return num1 + num2 # <- 本体（関数の実体）
```

「関数のシグネチャは嘘をつく」とは、関数がシグネチャに書いてある引数以外を利用して計算したり、戻り値以外を返す（例えば、例外のスロー）ことを指しています。
言い換えると、その関数が何をするのかはシグネチャに全て書いてあるべきであり、シグネチャから読み取れない処理を関数は行ってはいけない、ということを意味しています。

例えば上記関数`add_two_numbers`のシグネチャからは、「引数にある2つの整数（`int`型）を足した結果（`int`型であり、1つ）を返す」ことが容易に読み取れます。したがって、この関数のシグネチャは嘘つきでないと言えます。

本記事で関数型プログラミングを実践するにあたっては、この指摘を関数型プログラミングの観点に加えます。

## ツッコミの観点

以上を整理すると、本記事における関数型プログラミングのツッコミ観点は下記2つとなります。

**1. 関数のシグネチャが嘘をついていないか？**
**2. イミュータブルな値のみを操作しているか？**

この2つのツッコミにYESと答えられれば、本記事では、そのコードは関数型プログラミンを実践している、と言えることにします。

## 関数型ツッコミ

`ChatBot`クラスの各メソッドに対して関数型プログラミングの観点からツッコミを入れていきましょう。

### `def __init__(self, api_key: str):`

#### 1. 関数のシグネチャが嘘をついていないか？ ---> (Skip)

このメソッドはPythonにてクラスをインスタンス化する際に実行される特殊メソッドのため、この観点でのツッコミはスキップすることにしましょう。

#### 2. イミュータブルな値のみを操作しているか？ ---> Yes

このメソッドではミュータブル/イミュータブルな値の操作が発生していないため、Yesとなります。
（ただし、会話履歴を保持するリスト`self.message`を宣言しているため、他のメソッドにて、ミュータブルな値の操作するであろうことが「匂い」ます。）


### `def _create_and_send_message(self, user_message: str) -> str:`

#### 1. 関数のシグネチャが嘘をついていないか？ ---> No

シグネチャから読み取れることは下記のとおりです。

- 関数名の先頭に`_`があることから、クラス内でのみ使うことを開発者が意図していた[^1]
- 関数名から、この関数はメッセージを作成して送信する
- 引数と戻り値から、この関数は（インスタンスと）`str`型の「ユーザメッセージ」を受け取って、`str`型のナニカを返す

[^1]: [PEP 8 – Style Guide for Python Code / Descriptive: Naming Styles](https://peps.python.org/pep-0008/#descriptive-naming-styles)

関数の本体を見ると、このシグネチャに書かれていない重要な処理があります。それは例外処理です。
例外処理のハンドリングに関して、シグネチャに書かれていないことは下記の3つです。

1. OpenAI APIへのHTTP通信時に例外`httpx.HTTPStatusError`が発生し得る
2. 例外発生時はコンソールにメッセージを出力する
3. 例外発生時は`str`型のナニカを返さない

この関数のシグネチャは3つの嘘をついているので、このツッコミへの回答はNoとなります。

#### 2. イミュータブルな値のみを操作しているか？ ---> No

このメソッドではミュータブルな値`self.messages`に会話履歴を何度もappendしているため、このツッコミへの回答はNoとなります。


### `def start_chat(self) -> None:`

#### 1. 関数のシグネチャが嘘をついていないか？ ---> No

シグネチャからは、チャットを開始することと、`None`を返すことがわかります。
関数本体を見ると、`user_message == "/end`が`True`のとき、`break`が呼び出され、処理が強制的に終了しています。この内容はシグネチャに表れていません。そのため、このツッコミへの回答はNoとなります。

#### 2. イミュータブルな値のみを操作しているか？ ---> Yes

このメソッドではミュータブル/イミュータブルな値の操作が発生していないため、Yesとなります。




